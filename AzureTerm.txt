ヘルプ デスク ボットのハンズオン ラボ
これらのラボを通して、皆さんは、これからヘルプ デスク ボットを作成する方法について学習します。
また、C か Node.js のいずれかを選択することができると共に、詳細手順か基本手順のいずれかを選択することができます。
どちらの手順を使用してラボを完了してもかまいません。
基本手順は、最小限のガイダンスを提示し、自分でさまざまな課題に取り組みたいと考える開発者に課題を提供することを目的としています。
詳細手順は、より体系的な体験を希望する開発者に対して手引きとなる手順を示すことを目的としています。
まず、基本手順に目を通してから、これを補完する目的で詳細手順を用いると、演習をスムーズに完了できるでしょう。
すべての演習を順番どおりに実施しても、一部の演習を試してみるだけでもかまいません。
各演習では、開始点として使用するコードが指示されます 前の演習を実施していない場合。
Bot Builder SDK による初めての おうむ返し ボットの作成
ボットによるヘルプ デスク チケットの送信
言語理解の機能 LUIS によるボットのスマート化。
Azure Search と Cosmos DB によるヘルプ デスク KB の実装。
クラウドへのボットの展開	ドキュメント。
ユーザーのメッセージの背後にある感情の判別。
ヒューマン エージェントへの会話の受け渡し。
バックチャネルを通したイベントの送受信。
Bot Builder SDK for .NET による初めての おうむ返し ボットの作成。
この演習では、Bot Builder SDK for .NET を使用してボットを構築し、それを Bot Framework Emulator でテストする方法を示します。
Bot Builder SDK for .NET は、Visual Studio と Windows を使用してボットを開発するための、使いやすいフレームワークです。
SDK では C を活用し、.NET 開発者にとってなじみのある方法で強力なボットを作成する手段を提供します。
このフォルダーの中には、Visual Studio ソリューションと、この演習のステップで作成するコードが入っています。
このソリューションは、演習を進めるにあたってさらにヒントが必要な場合に、ガイダンスとして使用できます。
Bot Builder SDK for .NET は現在 C をサポートしています。
Visual Studio for Mac はサポートされていません。
この演習を完了するには、以下が必要です。
Visual Studio 2017 Community 以上
Bot Framework Emulator ボットのテストに使用するクライアント
ボット アプリケーション テンプレートを使用して新規ボットを作成する
ボット アプリケーション テンプレートをダウンロードし、.zip ファイルを Visual Studio 2017 プロジェクト テンプレート ディレクトリに保存してテンプレートをインストールします。
Visual Studio 2017 プロジェクト テンプレート ディレクトリは通常、以下の場所にあります。
%USERPROFILE%\Documents\Visual Studio 2017\Templates\ProjectTemplates\Visual C\
Visual Studio を開き、新規 C プロジェクトを作成します。
新規プロジェクトのボット アプリケーション テンプレートを選択します。
次の演習で名前空間の問題が発生するのを回避するために、プロジェクト名には HelpDeskBot を使用します。
ボット アプリケーション テンプレートを使用することで、単純なボットの作成に必要なすべてのコンポーネントが既に含まれているプロジェクトを作成することになります。
これには、Microsoft.Bot.Builder NuGet パッケージに含まれる Bot Builder SDK for .NET への参照も含まれます。
ただし、最初に、SDK の最新バージョンを使用していることを確認してください。
ソリューション エクスプローラーでプロジェクトの 参照 フォルダーを右クリックして、NuGet パッケージの管理 をクリックします。
更新 タブで、 Microsoft.Bot.Builder と入力します。
検索結果のリストでパッケージを見つけ、パッケージの 更新 ボタンをクリックします。
表示に従って、変更を受け入れ、パッケージを更新します。
ボット アプリケーション テンプレートを使用することで、プロジェクトには、このチュートリアルでボットを作成するために必要なコードがすべて含まれます。
際、追加のコードを記述する必要はありません。
しかし、ボットのテストに移る前に、ボット アプリケーション テンプレートのコードの一部を少し見てみましょう。
ボットのコードを調べる
最初に、Controllers\MessagesController.cs 内の Post メソッドがユーザーからメッセージを受信し、ルート ダイアログを呼び出します。
ダイアログは、会話のモデル化と会話のフローの管理に使用されます。
各ダイアログは、IDialog を実装する C クラスで自らの状態をカプセル化するアブストラクションです。
ダイアログは、別のダイアログで構成して再利用を最大化することができ、ダイアログのコンテキストは、任意の時点の会話でアクティブなダイアログのスタックを維持します。
また、ダイアログで構成される会話はコンピューター間で移植可能なため、ボットの実装の規模の調整が可能になります。
ルート ダイアログはメッセージを処理し、応答を生成します。
Dialogs\RootDialog.cs 内の MessageReceivedAsync メソッドは、ユーザーのメッセージの先頭に “You sent”、末尾に “which was  characters”  はユーザーのメッセージの文字数 のテキストを付けて、おうむ返しに返信を送ります。
ダイアログは、ボットのロジックを整理し、会話のフローを管理するのに役立ちます。
ダイアログはスタック化して配置され、スタックの最上位のダイアログは、ダイアログが閉じるか別のダイアログが呼び出されるまで、すべての受信メッセージを処理します。
ボットをテストする
次に、Bot Framework Emulator を使用してボットをテストし、動作の様子を見てみましょう。
このエミュレーターは、localhost 上のボット、またはトンネルを通じてリモートで実行しているボットをテストおよびデバッグできる、デスクトップ アプリケーションです。
エミュレーターは、Web チャットの UI に表示されるとおりにメッセージを表示し、JSON 要求をログに記録し、ユーザーがボットとメッセージをやり取りするとおりに応答します。
まず、エミュレーターをダウンロードしてインストールする必要があります。
こちらを参照してダウンロードしてください。
ダウンロードの完了後、実行可能ファイルを起動して、インストール プロセスを完了します。
エミュレーターのインストール後、IIS Express をアプリケーション ホストとして使用して、Visual Studio でボットを起動します。
実行 ボタンをクリックすると、以下のように、Visual Studio がアプリケーションを構築して localhost に展開し、Web ブラウザーを起動してアプリケーションの default.htm ページを表示します。
Windows ファイアウォールの警告が表示される場合は、アクセスを許可 をクリックします。
次に、エミュレーターを起動し、ボットに接続します。
アドレス バーに Local host と入力します。
これは、ボットがローカルにホストされたときにリッスンする既定のエンドポイントです。
ロケール を en-US に設定し、接続 をクリックします。
ボットをローカルに実行しているので、Microsoft App ID と Microsoft App Password を指定する必要はありません。
これらのフィールドは、今のところ空白のままにしてかまいません。
この情報は、演習 5 で Bot Framework Portal にボットを登録する際に取得します。
送信した各メッセージに対して、メッセージの先頭に You sent、末尾に which was  characters  はユーザーのメッセージの文字数 のテキストを付けて、おうむ返しにボットが応答するのを確認できます。
ボットによるヘルプ デスク チケットの送信 C
この演習では、ボットに会話機能を追加して、ヘルプ デスク チケットの作成をユーザーに案内する方法を学習します。
こちらのフォルダー内には、この演習のステップの完了結果として得られるコードを含むソリューションが入っています。
このソリューションは、演習を進めるにあたってさらにヒントが必要な場合に、ガイダンスとして使用できます。
この演習を完了するには、以下のソフトウェアが必要です。
Visual Studio 2017 Community 以上
Bot Framework Emulator en-US ロケールで構成されていることを確認してください
ボットへの会話の追加
このタスクでは、ボット コードを変更して、いくつかアクションを実行する前に、ユーザーに一連の質問をします。
前の演習から得られたソリューションを開きます。
または、exercise1-EchoBot フォルダーからソリューションを開くこともできます。
Dialogs\RootDialog.cs ファイルを開きます。
以下の変数を、RootDialog クラスの先頭に追加します。
この変数は、のちほどユーザーの回答を保存するために使用します。
MessageReceivedAsync メソッドを次のコードで置き換えます。
Dialog 実装が、会話フロー制御メソッドIDialogContext インターフェイスが提供 または、背後でIDialogContext メソッドを使用して会話フローを管理する PromptDialog ヘルパー メソッドの一部のいずれかを使用して、相互に接続されている一連のメソッドで構成されていることに気づくはずです。
最初に会話が始まったときは、ダイアログに状態が含まれないので、Conversation.SendAsync は RootDialog を構成し、StartAsync メソッドを呼び出します。
StartAsync メソッドは継続デリゲートで IDialogContext.Wait を呼び出し、そのメソッド この場合は MessageReceivedAsync メソッド を新しいメッセージの受信時に呼び出すように指定します。
Bot Framework SDK では、ユーザーからの入力の収集を簡単にするためのビルトイン プロンプトのセットを提供しています。
MessageReceivedAsync メソッドはメッセージを待機し、受信すると、ユーザーにあいさつを返し、PromptDialog.Text を呼び出して、問題について説明するよう求めます。
また、応答はフレームワークによりダイアログ インスタンスに保持されます。
これは Serializable としてマークされることに注意してください。
これは、ダイアログのステップ間で一時情報を保存するために重要です。
Visual Studio でソリューションを実行し 実行 ボタンをクリック、エミュレーターを開きます。
いつもどおりにボットの URL を入力し Local host 、以下に示すようにボットをテストします。
チケット詳細のプロンプト
このタスクでは、さらに多くのメッセージ ハンドラーをボット コードに追加して、チケットのすべての詳細について尋ねます。
アプリを終了し、Dialogs\RootDialog.cs ファイルを開きます。
DescriptionMessageReceivedAsync を更新して、ユーザーが入力した説明を保存し、チケットの重要度について尋ねます。
以下のコードでは、ユーザーに選択肢を示す PromptDialog.Choice メソッドを使用します。
次に、SeverityMessageReceivedAsync メソッドを追加します。
このメソッドは重要度を受信し PromptDialog.Text メソッドを使用して、ユーザーにカテゴリの入力を求めます。
今度は、CategoryMessageReceivedAsync メソッドを追加します。
このメソッドは、カテゴリを保存し、PromptDialog.Confirm メソッドを使用して、ユーザーにチケットの作成の確認を求めます。
Markdown 構文を使用して、よりリッチなテキスト メッセージを作成できることに注意してください。
ただし、すべてのチャネルで Markdown がサポートされるわけではないので、注意することが重要です。
メソッドを追加して、確認メッセージの応答を処理します。
アプリを再実行して、エミュレーターの Start new conversation ボタン  を使用します。
新しい会話をテストします。
この時点で再度ボットに話しかけると、ダイアログが最初から開始されます。
外部 API を呼び出してチケットを保存
これで、チケットのすべての情報が取得されましたが、この情報はダイアログが終了すると破棄されます。
今度は、外部 API を使用して、チケットを作成するコードを追加します。
わかりやすくするため、チケットをインメモリ アレイに保存する単純なエンドポイントを使用します。
実稼働環境では、ボットのコードからアクセスできる外部 API を使用することになります。
ボットについての重要事項として、構築するほとんどのボットが既存の API のフロント エンドとなるということに留意してください。
単純に言えば、ボットはアプリであり、人工知能 AI、機械学習 ML、または自然言語処理 NLP がなくてもボットとみなされます。
アプリを停止します。
Controllers フォルダーで、このハンズオン ラボの assets フォルダーの TicketsController.cs をコピーします。
これは、/api/tickets エンドポイントへの POST 要求を処理し、チケットをアレイに追加して、作成されたチケット ID を使用して応答します。
新しい Util フォルダーをプロジェクトに追加します。
新しいフォルダーで、ボットからチケット API を呼び出す TicketAPIClient.cs ファイルをコピーします。
appSettings セクションで TicketsAPIBaseUrl キーを追加して、Web.Config ファイルを更新します。
このキーには、チケット API を実行するベース URL が含まれます。
この演習では、ボットを実行する URL と同じになりますが、実稼働環境のシナリオでは別の URL になることがあります。
ステートメントを使用して HelpDeskBot.Util を追加します。
アプリを再実行して、エミュレーターの Start new conversation ボタン  を使用します。
すべての会話を再度テストして、API からチケット ID が返されることを確認します。
通知メッセージを変更してアダプティブ カードを表示
このタスクでは、チケットでアダプティブ カードを使用した後、ユーザーに表示される確認メッセージを向上させます。
アダプティブ カードとは、開発者が一定の共通方式で UI コンテンツをやり取りできるようにするための、オープン ソースのカード交換フォーマットです。
アダプティブ カードのコンテンツは、JSON オブジェクトとして指定できます。
コンテンツはホスト アプリケーション Bot Framework チャネル 内でネイティブにレンダリングでき、ホストの外観に自動的に適合します。
Microsoft.AdaptiveCards NuGet パッケージを追加する必要があります。
ソリューション エクスプローラー でプロジェクトの 参照 フォルダーを右クリックして、NuGet パッケージの管理 をクリックします。
Microsoft.AdaptiveCards を探し、インストール ボタンをクリックします。
または、パッケージ マネージャー コンソール で Install-Package Microsoft.AdaptiveCards と入力します。
Dialogs\RootDialog.cs ファイルを開きます。
ステートメントを使用して、System.Collections.Generic と AdaptiveCards を追加します。
ファイルの末尾 RootDialog クラス内 に、アダプティブ カードを作成する以下のコードを追加します。
このサンプル カードの詳細は、以下のとおりです。
ヘッダー セクションには、ticketID を含むタイトルが入ります。
中央のセクションには、ColumnSet と 2 つの列が含まれます。
1 列は重要度とカテゴリを含むFactSet、もう 1 列はアイコンが含まれます。
最後のセクションには、チケットについて説明する説明ブロックが含まれます。
IssueConfirmedMessageReceivedAsync メソッドを更新して、チケットが作成されたらこのメソッドを呼び出します。
アプリを再実行して、エミュレーターの Start new conversation ボタン  を使用します。
新しい会話をテストします。
アダプティブ カードについては、以下を参照してください。
自主的に学習を続ける場合は、次のタスクを利用できます。
conversationUpdate イベントを使用してボットにウェルカム メッセージを送信します。
詳細は、こちらを参照してください。
ボットがチケット API を呼び出す間、ボットにタイピング インジケーターを送信します。
詳細は、こちらを参照してください。
言語理解の機能によるボットのスマート化 C
人間とコンピューターとの対話式操作における大きな問題の 1 つに人間が何を欲しているかをコンピューターが理解する能力があります。
LUIS は、人間の言語を理解することにより、ユーザーの要求に応じることができるスマート アプリケーションを開発者が構築できるように設計されています。
この演習では、ヘルプ デスク ボットに自然言語理解機能を追加して、ユーザーがチケットを容易に作成できるようにする方法を学習します。
そのためには、Azure Cognitive Services オファリングの一部である LUIS Language Understanding Intelligent Service を使用します。
これはボットがコマンドを理解して行動できるようにさせるための言語モデルを、開発者が構築できるようにします。
たとえば、前の演習ではユーザーが重大度とカテゴリを入力する必要がありました。
今回は、ユーザーのメッセージから両方の エンティティ が認識されるようにします。
こちらのフォルダーの中には、Visual Studio ソリューションと、この演習のステップの完了結果として得られるコードが入っています。
このソリューションは、演習を進めるにあたってさらにヒントが必要な場合に、ガイダンスとして使用できます。
この演習を完了するには、以下のソフトウェアが必要です。
Visual Studio 2017 Community 以上
Azure サブスクリプション
Bot Framework Emulator en-US ロケールで構成されていることを確認します
LUIS ポータルのアカウント
LUIS アプリを作成する
このタスクでは、LUIS ポータルでアプリを作成します。
既に LUIS に習熟している場合は、この演習の assets フォルダーにあるファイル luis_model.json を各自のアカウントにインポートして、モデルをトレーニングおよび発行し、タスク 4 に進むことができます。
しかし、LUIS の初心者である場合は、学習のためにモデルを最初から作成することをお勧めします。
LUIS ポータルに移動してサインインします。
My apps タブを開きます。
New App をクリックします。
ダイアログ ボックスにアプリケーションの名前 たとえば、 HelpDeskBot  を入力します。
まだ選択されていない場合は、Culture で English を選択します。
Key to use を選択します。
まだ何も選択していない場合は、既定として BoostrapKey が作成されます。
Create をクリックします。
空の LUIS アプリ ダッシュボードが表示されます。
後で使用できるように App ID を保存します。
ページ上部の My keys メニューに移動します。
移動すると、後での使用に備えて保存した Programmatic API キーが表示されます。
LUIS に新しいエンティティを追加する
このタスクでは、LUIS アプリにエンティティを追加します。
これによって、ボットはチケットのカテゴリと重大度を、ユーザーが入力した問題の説明から理解できるようになります。
エンティティはアプリケーションのドメインの 名前 です。
エンティティは、類似のオブジェクト 場所、もの、人間、イベントまたは概念 の集合を含むクラスを表します。
このラボでは、List エンティティ タイプを使用します。
これにより、一般に クローズド リスト と呼ばれるものを作成できます。
これは、用語に機械学習を適用せず、直接一致を使用することを意味します。
用語の正規化の試行時、または一定のキーワードが常にエンティティとしてピックアップされることを保証する場合に非常に有益です。
LUIS ポータルの左パネルで Entities をクリックします。
Add custom entity をクリックします。
表示されたダイアログで Entity name に category と入力します。
Entity type には List を選択します。
Save をクリックします。
新しいページが表示され、そのページで使用可能な値を追加できます。
この処理をスピードアップするには、Imports Lists リンクをクリックします。
このハンズオン ラボのルートにある assets フォルダーで categories.json ファイルを探します。
有効化したら、Import をクリックします。
severity という名前の新しいエンティティでもこの処理を繰り返します、同じ場所にある severities.json という名前のファイルを使用して読み込みます。
次に、左パネルの Train & Test をクリックします。
Train Application をクリックして、完了するまで数秒間待ちます。
現在のモデルを更新する際はいつでも、アプリをトレーニングしてからテスト/発行する必要があります。
インテントおよび発話を追加する
インテントは発話 文 を通じて伝達される意図または望まれるアクションです。
インテントは、ボットにアクションを実行させることでユーザーの要求に応じます。
このため、ボットがユーザーの要求を理解し、適切に対応できるようにインテントを追加する必要があります。
発話は、ボットに受信/解釈させるためのユーザー クエリやコマンドのサンプルを表す文です。
アプリ内の各インテントにサンプルの発話を追加する必要があります。
LUIS がこれらの発話から学習すると、アプリは同様のコンテキストの一般化および理解が可能になります。
発話を継続的に追加して、ラベル付けすることで、ボットの言語学習エクスペリエンスが向上します。
インテントの詳細については、こちらを、発話についてはこちらを参照してください。
LUIS ポータルの左パネルで Intents をクリックします。
既に None インテントが存在することがわかります。
Add Intent をクリックすると、ポップアップが表示されます。
Intent name に SubmitTicket と入力して、Save をクリックします。
次は、テキスト ボックスに次の発話を追加します。
1 つ入力するごとに Enter キーを押します。
ユーザーがこれらの文または類似の文を入力すると、LUIS アプリはユーザーがチケットを送信しようとしていると想定します。
Bot Framework 言語ではこれを インテント と呼びます。
I can't log in, I'm blocked. ログインできません。
ブロックされています。
I cannot print and I need to do it urgently. 印刷できません、すぐに印刷する必要があります。
I need to request a new RAS token. 新しい RAS トークンを要求する必要があります。
I need to reset my password ASAP. 即座にパスワードをリセットする必要があります。
I cannot open a web page and my deadline is at risk. Web ページが開けません、期限が迫っています。
発話は必要なだけ追加できます。
追加する発話が多いほど、アプリがユーザーのインテントを認識する能力が高まります。
ここで使用する例の場合、非常に多様な発話 ハードウェアの問題もあれば、ソフトウェアの問題もあります が SubmitTicket を起動する可能性があるため、ボットを実稼働に向けてリリースする前に大量の発話でボットをトレーニングすることが理想です。
Save  をクリックします。
前述の手順を使用して、発話を help、hi、hello として新しい Help インテントを追加します。
他のインテントと異なる場合でも、None インテントに発話をいくつか追加することをお勧めします。
トレーニング サンプルを指定しても、None インテントを起動するテキストに制約はかかりませんが、他のインテントの起動精度の向上に役立ちます。
前述の説明に従って、アプリを再度トレーニングします。
Intents メニューを開き、SubmitTicket インテントをクリックします。
発話がエンティティ値によって認識されることを確認します。
次に、LUIS アプリを発行してボットから使用できるようにします。
左側のメニューの Publish App をクリックします。
Endpoint key が選択されていることを確認します。
既定の Production スロットはそのままにします。
Publish をクリックします。
新しい確認メッセージの表示後に LUIS アプリが発行されます。
LUIS アプリの出力が、HTTP エンドポイント 自然言語の理解を追加する際にボットから参照する が設定された Web サービスであることがわかります。
BoostrapKey は 1 か月あたり 1000 のトランザクションが存在します。
LUIS を使用するようにボットを更新する
このタスクでは、ボット コードを更新して、前の手順で作成した LUIS アプリを使用するようにします。
前の演習から得られたソリューションを開きます。
または、exercise2-TicketSubmissionDialog フォルダーから Exercise2.sln ソリューションを開くこともできます。
Dialogs\RootDialog.cs ファイルを開きます。
ステートメントを使用して Microsoft.Bot.Builder.Luis と Microsoft.Bot.Builder.Luis.Models を追加します。
次のようにして、LuisModel 属性をクラスに追加します。
{LUISAppID} を LUIS ポータルから保存したアプリ ID に置き換え、{LUISKey} を My Keys セクションから保存したプログラマティック API キーに置き換えます。
インターフェイス IDialog の実装を、LuisDialog<object> から導出するように置き換えます。
メソッド StartAsync、MessageReceivedAsync、および DescriptionMessageReceivedAsync は、呼び出されなくなるため、削除します。
LUIS モデルがインテントを検出したときに実行される None メソッドを作成します。
属性 LuisIntent を使用し、インテント名をパラメーターとして渡します。
次のコードを追加して、ユーザーにメッセージで応答するHelp インテントを処理します。
次のコードを追加して、インテント SubmitTicket を処理するメソッドを追加します。
TryFindEntity メソッドを使用して、発話にエンティティが存在するかどうかを判定して、それを抽出します。
次に、EnsureTicket メソッドを作成します。
これは、エンティティが識別されたかどうかを検証し、識別されていない場合はユーザーに不足のエンティティの入力を求めるものです。
次のように、SeverityMessageReceivedAsync および CategoryMessageReceivedAsync を更新して、EnsureTicket メソッドをコール バックするようにします。
エミュレーターからボットをテストする
アプリを実行してエミュレーターを開きます。
ボットの URL Local host をいつもどおり入力します。
 hi と入力します。
Help インテントがどのように認識され、実行されるかがわかります。
ボットのトレーニングに使用した発話のいずれかを入力します。
たとえば I can't log in, I'm blocked と入力します。
ユーザーのメッセージから、チケットのカテゴリおよび重大度が自動的に把握されます。
 yes と入力して、チケットを保存します。
次に、ボットのトレーニングに使用されていない発話を入力してみます。
 My computer is making a grinding noise. コンピューターが摩擦音を立てています 重大度は把握されていませんが、エンティティ computer が存在するためカテゴリは把握されています。
LUIS が認識できない発話を入力すると、LUIS は “None” インテントを返し、ボット フレームワークは既定のダイアログ ハンドラーを実行します。
アプリケーションを展開し、システムにトラフィックへの流入が開始すると、LUIS はアクティブ ラーニングを使用して、自己改善します。
アクティブ ラーニング プロセスで、LUIS はあまり確信できない発話を特定して、インテントまたはエンティティに従ってその発話にラベル付けすることを求めます。
LUIS ポータルのインテント内には Suggested Utterances セクションが存在し、そこではラベル付けを実行できます。
自主的に学習を続ける場合は、次のタスクを利用できます。
cancelActionを使用して SubmitTicket ダイアログにキャンセル イベント ハンドラーを追加する。
beginDialogAction を使用して SubmitTicket 内でユーザーにヘルプを提供するためのカスタム ダイアログを追加する。
onEnabled イベントを使用して、cancel が呼び出されない限り、開始された SubmitDialog が完了することを保証する。
チケットのステータスをボットに要求する機能を追加する。
チケットにステータス プロパティを追加し、新しいダイアログを起動する LUIS アプリの新しいインテントを追加する必要があります。
Azure Search と Cosmos DB によるヘルプ デスク ナレッジ ベースの実装 C
ボットは、ユーザーが大量のコンテンツをナビゲートする支援を行い、ユーザーのためにデータ駆動型の検索エクスペリエンスを実現することもできます。
この演習では、検索機能をボットに追加し、ユーザーがナレッジ ベースを検索する支援を行う方法について学習します。
これを行うには、Azure Cosmos DB に保管されている KB の記事のインデックスを作成する Azure Search サービスにボットを接続します。
Azure Cosmos DB は、マイクロソフトが提供する、ミッション クリティカルなアプリケーション向けのグローバル分散型マルチ モデル データベース サービスです。
Azure Cosmos DB は、さまざまなデータ モデルをサポートします。
この演習では、Azure Cosmos DB の DocumentDB API を使用します。
これを使用することで、ナレッジ ベースの記事を JSON ドキュメントとして保管できます。
Azure Search は、カスタム アプリケーションで充実した検索エクスペリエンスを実現する完全管理型のクラウド検索サービスです。
Azure Search は、さまざまなソース Azure SQL DB、Cosmos DB、BLOB ストレージ、テーブル ストレージ のコンテンツのインデックスを作成でき、その他のデータ ソースに対応する プッシュ型 のインデックス作成をサポートします。
また、PDF、Office ドキュメント、および非構造化データが含まれるその他の形式のドキュメントを開くことができます。
コンテンツ カタログが Azure Search インデックスに取り込まれることで、ボットのダイアログからクエリを行えるようになります。
このラボでは Azure Search と Azure Cosmos DB を使用しますが、どの検索エンジンおよびバッキング ストアを使用してももちろんかまいません。
こちらのフォルダー内には、この演習のステップの完了結果として得られるコードを含むソリューションが入っています。
このソリューションは、演習を進めるにあたってさらにヒントが必要な場合に、ガイダンスとして使用できます。
これを使用する前に、まず Web.config で LUIS モデルの値、および Azure Search インデックスの名前とキーを指定しておく必要があることを覚えておいてください。
次の図は、コンポーネントどうしがどのようなやりとりをするかを示したものです。
この演習を完了するには、以下のソフトウェアが必要です。
Visual Studio 2017 Community 以上
Azure サブスクリプション
Bot Framework Emulator en-US ロケールで構成されていることを確認してください
LUIS ポータルのアカウント
Cosmos DB サービスを作成し、ナレッジ ベースをアップロードする
このタスクでは、Cosmos DB データベースを作成し、ボットによって使用されるいくつかのドキュメントをアップロードします。
Azure Cosmos DB の仕組みについてよくわからない場合は、こちらのドキュメントを参照してください。
Azure ポータルにアクセスしてサインインします。
左側のバーにある 新規 ボタン  をクリックし、次に データベース をクリックして、Azure Cosmos DB を選択します。
ダイアログ ボックスで一意のアカウント ID  help-desk-bot を入力し、API で SQL DocumentDB を選択します。
新しいリソース グループ名を入力し、作成 をクリックします。
展開が完了するまで待ちます。
先ほど作成した Cosmos DB アカウントを開き、 セクションに移動します。
コレクションの追加 ボタンをクリックします。
ダイアログ ボックスの コレクション ID で knowledge-base と入力し、ストレージ容量 で Fixed を選択して、データベース名として knowledge-base-db と入力します。
OK をクリックします。
左側のパネルで ドキュメント エクスプローラー を選択し、次に アップロード ボタンをクリックします。
開いたウィンドウで、assets/kb フォルダーのファイルをすべて選択します。
各ファイルは、ナレッジ ベースの 1 つの記事に相当します。
アップロード をクリックします。
ブラウザーを閉じないでください。
記事の ドキュメント にはそれぞれ 3 つのフィールド タイトル、カテゴリ、およびテキスト が含まれています。
Azure Search サービスを作成する
このタスクでは、Cosmos DB にアップロードされたコンテンツのインデックスを作成するための Azure Search サービスを作成します。
Azure ポータルの左側のバーにある 新規  をクリックし、次に Web + モバイル をクリックして、Azure Search を選択し、作成 ボタンをクリックします。
一意の URL  help-desk-bot-search を入力し、後で使用するために保存します。
Cosmos DB で使用したものと同じリソース グループを選択します。
Price Tier を 無料 に変更し、作成 をクリックします。
サービスのプロビジョニング後、 に移動してから データのインポート ボタン  をクリックします。
データに接続します ボタン、DocumentDB の順にクリックします。
データ ソース名として knowledge-base-datasource と入力します。
先ほど作成した Cosmos DB のアカウント、データベース、およびコレクションを選択します。
OK をクリックします。
Index - Customize target index ボタンをクリックします。
インデックス名 で knowledge-base-index と入力します。
インデックスの定義が以下の図と一致するように各列のチェックボックスを更新します。
OK をクリックします。
カテゴリ フィールドの フィルター可能 と ファセット可能 にチェックマークが付いていることを確認します。
これにより、カテゴリが一致するすべての記事を取得できると共に、各カテゴリの記事の数も取得できるようになります。
これは、Azure Search の専門用語で ファセット ナビゲーション と呼ばれます。
インデックスの詳細については、こちらの記事を参照してください。
最後に、Indexer - Import your data をクリックします。
名前 で knowledge-base-indexer と入力します。
スケジュール で 1 度 が選択されていることを確認します。
OK をクリックします。
再び OK をクリックし、データのインポート ダイアログを閉じます。
左側で キー をクリックし、次に クエリ キーの管理 をクリックします。
次のタスクで使用するために、既定の Azure Search キー <empty> という名前で示されています を保存します。
クエリ キーは、管理キーとは異なり、Search インデックスの読み取り専用の操作  ID によるドキュメントのクエリと検索 でしか使用できません。
プライマリ管理キーとセカンダリ管理キーは、すべての操作  サービスの管理、インデックス、インデクサー、データ ソースの作成と削除 を行える完全な権限を付与します。
ExploreKnowledgeBase インテントが含まれるように LUIS モデルを更新する
このタスクでは、ナレッジ ベースを検索するために LUIS に新しいインテントを追加します。
LUIS ポータル にサインインします。
演習 3 で作成したアプリを編集します。
左側のメニューで Intents をクリックし、次に Add Intent ボタンをクリックします。
インテント名として ExploreKnowledgeBase と入力してから、以下の発話を追加します。
Save をクリックします。
左側にある Publish App リンクをクリックします。
Train ボタンをクリックし、完了したら Publish ボタンをクリックします。
Azure Search API を呼び出せるようにボットを更新する
このタスクでは、先ほど作成したインテントに対応し、Azure Search サービスを呼び出すためのダイアログを追加します。
前の演習から得られたソリューションを開きます。
開始点としてこちらのソリューションを使用してもかまいません。
その場合は、Dialogs\RootDialog.cs 内の LuisModel{LUISAppID}, {LUISKey} 属性のプレースホルダーを自分が使用している LUIS アプリ ID とプログラマティック API キーに置き換えてください。
前のタスクで作成した Azure Search サービスを使用するには、appSettings セクションの Web.config で以下のキーを追加します。
AzureSearchAccountName と AzureSearchKey は タスク 2 で作成した値を指定する必要があります。
新しい Model フォルダーをプロジェクトに追加します。
assets フォルダーから新しいフォルダーに SearchResult.cs と SearchResultHit.cs をコピーします。
これらのクラスは、Azure からの記事の検索に対応します。
プロジェクトで Services フォルダーを作成し、以下のコード内に AzureSearchService クラスを追加します。
この演習では、単純な Search のクエリしか行わないため、Azure Search REST API を直接使用します。
より複雑な操作を行う場合は、Azure Search .NET SDK を使用できます。
この SDK は、管理操作  Search サービスの作成と拡張、API キーの管理 をサポートしません。
Dialogs フォルダー内で、Azure Search とやりとりを行うための新しい CategoryExplorerDialog クラスを作成します。
ここで、新しい ExploreKnowledgeBase インテントに対応し、ユーザーが入力したカテゴリに属する記事の一覧を Azure Search から取得するための ExploreCategory メソッドを RootDialog クラスに追加します。
この時点でボットをテストする
実行 ボタンをクリックしてアプリを実行し、エミュレーターを開きます。
ボットの URL Local host  をいつもどおり入力します。
 explore hardware と入力します。
そのカテゴリに属する記事がボットにより一覧表示されることを確認します。
他のカテゴリ値  ネットワーキング、ソフトウェア で試してもかまいません。
カテゴリと記事を表示できるようにボットを更新する
このタスクでは、ナレッジ ベースをカテゴリでナビゲートし、特定のテーマに関する情報を取得できるようにボットのコードを更新します。
アプリを停止します。
assets フォルダーからプロジェクトの Model フォルダーにファイル FacetResult.cs、SearchFacets.cs、および Category.cs をコピーします。
これらのクラスは、Azure Search サービスのクエリに必要となります。
AzureSearchService クラスに以下のメソッドを追加します。
カテゴリを取得して、それらを一覧表示するための FetchFacets メソッドを追加します。
facet=category クエリを使用してこれが行われることを確認します。
これは、すべての記事に適用できるすべての カテゴリ フィルター をインデックスから取得します この場合は、ソフトウェア、ハードウェア、ネットワーキングなど。
また、Azure Search は、各ファセットの記事の数を返します。
記事を取得するための SearchByTitle メソッドを追加します。
わかりやすくするために、記事のコンテンツは Azure Search から直接取得されます。
しかしながら、本番のシナリオでは、Azure Search はインデックスとしてのみ機能し、記事の全文は Cosmos DB から取得されます。
一般的な検索を行うための Search メソッドを追加します。
Azure Search では、search=... クエリは、インデックス内のすべての検索可能フィールドの用語を 1 つ以上検索し、Google や Bing などの検索エンジンと同様に機能します。
filter=... クエリは、インデックス内のすべてのフィルター可能フィールドでブール式を評価します。
検索クエリとは異なり、フィルター クエリは、フィールドの正確なコンテンツのマッチングを行います。
つまり、文字列フィールドの大文字と小文字が区別されます。
assets フォルダーからプロジェクトの Util フォルダーに CardUtil.cs ファイルをコピーします。
このクラスは、Azure Search からの記事の一覧で ThumbnailCard のカルーセルを作成するのに使用されます。
ユーザーに対してリッチなカードを示す方法の詳細については、こちらの記事を参照してください。
assets フォルダーからプロジェクトの Dialogs フォルダーに SearchScorable.cs と ShowArticleDetailsScorable.cs をコピーします。
これらのクラスは、ボットに送信されるすべてのメッセージをインターセプトし、検索サービスを起動する Scorable です。
SearchScorable は、メッセージが search about で始まる場合に起動され、AzureSearchService の Search メソッドを呼び出します。
ShowArticleDetailsScorable は、メッセージが show me the article で始まる場合に起動され、AzureSearchService の SearchByTitle メソッドを呼び出します。
Scorable は、会話に送信されるすべてのメッセージをインターセプトし、定義したロジックに基づいてメッセージにスコアを付けます。
最もスコアの高い Scorable がメッセージ もっと正確に言えば、会話に送信されるメッセージ を処理する機会を 獲得 します。
ボットで実装するグローバル コマンドごとに Scorable を作成することで、グローバル メッセージ ハンドラーを実装できます。
Scorable の詳細については、こちらのサンプルを参照してください。
Global.asax.cs を開き、以下の using ステートメントを追加します。
同じファイルで、Application_Start メソッドを以下のコードに置き換え、会話コンテナーに Scorable を登録します。
AfterMenuSelection メソッドを追加します。
このメソッドは、ユーザーが検索するカテゴリを選択する際に呼び出されます。
最後に、RootDialog で、CategoryExplorerDialog の署名のマッチングを行えるように ExploreCategory メソッドを更新します。
また、ナレッジ ベースの機能が含まれるように Help メソッドのテキストを更新できます。
エミュレーターからボットをテストする
実行 ボタンをクリックしてアプリを実行し、エミュレーターを開きます。
ボットの URL Local host  をいつもどおり入力します。
 explore knowledge base と入力します。
Cosmos DB にアップロードした記事カテゴリの一覧、および各カテゴリの記事の数が表示されます。
一覧表示されたカテゴリのいずれかをクリックすると、そのカテゴリの記事が表示されます。
記事の More Details ボタンをクリックすると、記事の全文が表示されます。
特定のカテゴリを検索してみてもかまいません。
 explore software と入力すると、そのカテゴリに属する記事がいくつか表示されます。
同様に、特定のトピックに関する記事を検索してみてもかまいません。
たとえば、 search about OneDrive と入力します。
検索によって返されるドキュメントごとにスコア 関連度 が返されることを確認してください。
自主的に学習を続ける場合は、次のタスクを利用できます。
記事 ThumbnailCard で既定の画像を表示する代わりに、Bing Image Search API を使用して、記事のカテゴリに関連する画像を表示できます。
こちらで提供されている assets フォルダーのコードを使用できます。
カルーセルで使用される記事 ThumbnailCard をアダプティブ カードで変更できます。
例としてこちらで提供されているコードを使用できます。
クラウドへのボットの展開 C
この演習では、自分のボットを登録し、Azure に展開して、他の人々がそのボットを使用できるようにする方法を学習します。
この演習を完了するには、以下のソフトウェアが必要です。
Visual Studio 2017 Community 以上
Azure サブスクリプション
LUIS ポータルのアカウント
Skype アカウント オプション
Bot Framework へのボットの登録
このタスクでは、アプリ ID とアプリ パスワードを生成し、ボットを登録します。
Bot Framework Portal にサインインします。
My bots ボタンをクリックし、次に Create a bot をクリックするか 他のボットがある場合、または Register ボタンをクリックします。
logo.png をカスタム アイコンとしてアップロードします。
Display Name に Help Desk Bot と入力します。
Bot Handle にグローバル一意アプリ名を入力します。
Long Description には、 This bot will try to help you to solve common issues and can raise tricky ones as tickets. と入力してください。
この説明は検索結果で表示されるため、ボットの機能を正確に記述してください。
Configuration セクションで、Create Microsoft AppID and Password ボタンをクリックします。
それにより、新しいページが開きます。
必要に応じて、Bot Framework Portal で使用した資格情報を入力して、もう一度サインインしてください。
このページには、先ほど入力したアプリ名と、自動生成されたアプリ ID が表示されます。
アプリ ID は後から確認できるように保存しておき、アプリパスワードを生成して続行 をクリックします。
ポップアップが開き、自動生成されたボット用パスワードが表示されます。
このパスワードが表示されるのはこの 1 回限りです。
後から確認できるように安全な方法で保管しておいてください。
OK をクリックしてポップアップを閉じます。
Finish and go back to Bot Framework ボタンをクリックします。
ページが閉じ、ボット登録画面に戻ります。
ページに、アプリ ID が表示されるようになりました。
画面を下にスクロールして、使用条件、プライバシーに関する声明、および倫理規定への同意について確認します。
Register ボタンをクリックします。
確認メッセージが表示されます。
OK をクリックします。
次に、ボットのダッシュボードが表示されます。
いくつかのチャネルが利用可能になっています。
Azure へのボットの発行
このタスクでは、Visual Studio から Azure へボットを発行する方法を学習します。
前の演習から得られたソリューションを開きます。
または、exercise4-KnowledgeBase フォルダーからソリューション ファイルを開くこともできます。
その場合は、Dialogs\RootDialog.cs 内の LuisModel{LUISAppID}, {LUISKey} 属性のプレースホルダーを自分が使用している LUIS アプリ ID とプログラマティック API キーに置き換えてください。
Build メニューに移動して、Publish HelpDeskBot または自分が使用しているプロジェクト名 をクリックします。
表示されたウィンドウで、Microsoft Azure App Service、新規作成 をクリックし、発行 をクリックします。
新しいウィンドウが開きます。
アプリ名 にアプリ名を入力し、サブスクリプション でサブスクリプションを、リソース グループ でリソース グループをそれぞれ選択します。
Cosmos DB および Search サービスで使用したものと同じリソース グループを使用できます。
作成 ボタンをクリックします。
次に、展開によってサブスクリプションでの Web アプリの作成が開始されます。
完了すると、既定の Web ブラウザーが開き、ボット URL にリダイレクトされます。
Azure Web アプリの構成
このタスクでは、Bot Framework のチャネルと通信できるようにアプリを構成する方法を学習します。
Azure ポータルにサインインします。
前に作成したアプリ サービスを開きます。
左側のメニューにある Application Settings をクリックします。
App settings に移動して、以下のキーを追加し、それぞれの値を説明に従って置き換えます これらの値はボットのソース コードに含まれているはずです。
キーと値の入力が完了すると、次の図のような結果になるはずです。
Save  をクリックします。
ボット構成の更新
Bot Framework Portal に移動します。
ボットを編集するために、ボット名をクリックします。
ページの右上隅にある Settings ボタンをクリックします。
Configuration セクションで、タスク 2 で作成したアプリ サービス URL  https://help-desk-bot.azurewebsites.net/api/messages を入力します。
URL の末尾には必ず /api/messages を付け、またプロトコルは必ず https にしてください。
ページ下部の Save changes ボタンをクリックします。
発行したボットのテスト
このタスクでは、他のチャネルからボットをテストします。
ページの右上隅にある Test ボタンをクリックします。
ページの右側に新しいウィンドウが開きます。
これは、ボットを容易にテストできるようにする埋め込みの Web チャット チャネルです。
 Hi! I want to explore the knowledge base. と入力し、この入力への応答としてボットがカテゴリ一覧を返すことを確認します。
任意のカテゴリをクリックして、そのカテゴリの記事一覧が表示されることを確認し、いずれかの記事をクリックして内容を確認します。
Channels メニュー項目をクリックします。
Skype チャネルと Web チャット チャネルが既定で有効になっているはずです。
Skype リンクをクリックします。
新しいページが開きます。
このページで、Skype アカウントにボットを追加できます。
Add to Contacts ボタンをクリックします。
Skype アカウントにサインインするように求められ、Skype アプリが開かれるはずです。
Get bot embed codes リンクについても確認してみてください。
ここでは、ユーザーが自分の Skype アカウントにボットを追加できるようにするためのリンクの構築方法がわかります。
連絡先リストでボットを検索して、新しい会話をテストします。
このハンズオン ラボの作成時点で、Skype はアダプティブ カードを完全にサポートしてはいないため、チケット確認メッセージが正しく表示されない可能性があります。
Bot Emulator でボットをテストします。
ngrok を使用して、ローカル コンピューターへの応答方法をボットに知らせる必要があります。
そのための手順については、こちらを参照してください。
Application Insights を使用した Bot Analytics の追加も試してみてください。
方法については、こちらを参照してください。
ユーザーのメッセージの背後にあるセンチメントの判別 C
ユーザーとボットとの対話はほとんどの場合自由形式で行われるため、ボットは言語を自然に、かつ文脈に応じて理解する必要があります。
この演習では、Azure Text Analytics API を使用してユーザーの感情や気分を検出する方法を学習します。
Azure Cognitive Services オファリングの一部である Text Analytics API を使用することによって、センチメント、キー フレーズ、トピック、および言語をテキストから検出できます。
この API は 0 ～ 1 の数字によるスコアを返します。
1 に近いスコアは肯定的なセンチメントを、0 に近いスコアは否定的なセンチメントを示します。
センチメント スコアは、分類の手法により生成されます。
こちらのフォルダー内には、この演習のステップで作成するコードを含むソリューションが入っています。
このソリューションは、演習を進めるにあたってさらにヒントが必要な場合に、ガイダンスとして使用できます。
このソリューションを使用する場合は、必ず事前に Web.config で値を設定してください。
前の課題から引き続いて行う場合は、web.config にある appSettings の値を初期値に戻す必要があります。
この演習を完了するには、以下のソフトウェアが必要です。
Visual Studio 2017 Community 以上
Azure サブスクリプション
Bot Framework Emulator en-US ロケールで構成されていることを確認してください
Text Analytics API キーの作成
このタスクでは、Text Analytics アカウントを作成します。
こちらを参照して、言語 タブをクリックします。
Text Analytics API を見つけて 作成 をクリックします。
使用条件に同意し、国を選択するように求められます。
次に、次へ をクリックします。
Azure サブスクリプション アカウントでログインします。
1 か月あたり 5,000 の無料要求が可能な評価キーを含む次のようなページが表示されます。
後で使用できるように、キーの 1 つを保存しておきます。
Text Analytics API クライアントの追加
このタスクでは、ボットから Text Analytics API を呼び出す新しいクラスを作成します。
前の課題から得られたソリューションを開きます。
または、exercise4-KnowledgeBase フォルダーにあるアプリを使用することもできます。
あらかじめ提供しているソリューションを使用する場合は、必ず以下の値を置き換えてください。
Dialogs\RootDialog.cs 内の LuisModel{LUISAppID}, {LUISKey} 属性を自分が使用している LUIS アプリ ID とプログラマティック API キーに置き換えます。
Web.config 内の AzureSearchAccount、AzureSearchIndex、および AzureSearchKey を、自分の Search アカウント、インデックス名、およびキーに置き換えます 演習 4 で説明しています。
プロジェクトの Services フォルダー内の TextAnalyticsService.cs をコピーします。
このファイルには、Text Analytics API を使用する 3 つのクラスが含まれています。
クライアントは /sentiment エンドポイントにアクセスしていますが、Text Analytics API は /keyPhrases エンドポイントと /languages エンドポイントも提供します。
また、複数のドキュメントを分析用に送信できます。
プロジェクトのルート フォルダーにある Web.Config ファイルの appSettings セクションでキー TextAnalyticsApiKey を追加することによって、このファイルを更新します。
TextAnalyticsApiKey の値として、前のタスクで得られた Text Analytics キーを設定します。
次のコード例を使用して、Dialogs フォルダーに新しいクラス UserFeedbackRequestDialog.cs を作成します。
このダイアログは、サービスとの対話を処理する役割を担います。
StartAsync メソッドの実装を、そのボットに関するフィードバックの提供をユーザーに求めるものに置き換えます。
MessageReciveAsync という新しいメソッドを追加します。
このメソッドは、ユーザーの応答を受け取って Text Analytics API に送ります。
それにより、この API でユーザーのセンチメントを評価できるようにします。
応答内容 スコアが 0.5 より高いか、低いか に応じて異なるメッセージがユーザーに表示されます。
センチメント分析では、テキストを文に分割することをお勧めします。
一般に、この分割によって、センチメント予測の精度が向上します。
フィードバックを要求してユーザーのセンチメントを分析できるようにするためのボットの変更
エミュレーターからのボットのテスト
実行 ボタンをクリックしてアプリを実行し、エミュレーターを開きます。
ボットの URL Local host  をいつもどおり入力します。
 I need to reset my password. と入力し、次に重大度を選択します。
チケットの送信を確認し、フィードバックについての新たな要求をチェックします。
 It was very useful and quick. と入力します。
肯定的なフィードバックだったことを意味する次のような応答が表示されます。
チケットの送信をもう一度行い、ボットからフィードバックを求められたら、 It was useless and time wasting. と入力します。
否定的なフィードバックだったことを意味する次のような応答が表示されます。
この後の演習 7 では、会話を人間の担当者に引き渡し ハンドオフ、担当者を通じてユーザーを支援する方法について学習します。
自主的に学習を続ける場合は、次のタスクを利用できます。
Microsoft Cognitive Services 内の別のサービスを使用して、ボットに音声認識機能を追加できます。
Bing Speech API を試してみてください。
ヒューマン エージェントへの会話のハンドオフ C
ボットが持つ人工知能の能力がどんなに大きくても、まだ会話を人間にハンドオフしなければならない状況が発生することがあります。
たとえば、質問に自動的に返信し、場所を問わずお客様に対応できる一方で、問題を人間にエスカレートできるボットを構築する必要があるでしょう。
またボットがすべての状況に対応できない場合や、エッジケースが存在する場合、ボットは適切な権限を持つ人間にその対応を任せることができなければなりません。
ボットはハンドオフが必要なタイミングを認識し、明確かつスムーズなハンドオフを実現する必要があります。
この演習では、ボットを利用してユーザーと会話を開始し、コンテキストをヒューマン エージェントにハンドオフする方法を学習します。
最初に、Scorable を使用して送受信イベント/メッセージをインターセプトする方法を学習します。
これを使用して、ユーザーとエージェント間の通信およびエージェントのみで利用できる特別なコマンドを処理します。
後半では、新しい Scorable を使用するようにボットを変更し、ボットの会話をヒューマン エージェントにハンドオフするダイアログを追加します。
こちらのフォルダー内には、この演習で作成するコードを含むソリューションが入っています。
このソリューションは、演習を進めるにあたってさらにヒントが必要な場合に、ガイダンスとして使用できます。
Scorable を使用する場合は、最初に Web.config でキーを作成する必要があります。
この演習で使用するハンドオフ アプローチの詳細については、BUILD 2017 のこちらのセッションを参照してください。
この図は、この演習用のボットのコンポーネントを簡単に示しています。
この演習を完了するには、以下のソフトウェアが必要です。
Visual Studio 2017 Community 以上
Azure サブスクリプション
LUIS ポータルのアカウント
Bot Framework Emulator en-US ロケールで構成されていることを確認してください
ハンドオフ ロジックの構築
このタスクでは、2 人の人物 ユーザーとエージェント を橋渡しする通信を処理するために必要な 裏側 のロジックを追加します。
送受信イベント/メッセージをインターセプトする Scorable を作成して配置する方法を学習します。
Bot Builder SDK for .NET の Scorable により、ボットは会話に送信されるすべてのメッセージをインターセプトし、定義されたロジックに基づいてメッセージにスコアを適用できます。
Scorable を作成するには、ScorableBase 抽象クラスを継承して、IScorable インターフェイスを実装するクラスを作成します。
その Scorable を会話内のすべてのメッセージに適用するために、ボットはその IScorable インターフェイスをサービスとして会話のコンテナに登録します。
新しいメッセージが会話に届くと、そのメッセージはコンテナ内の IScorable の各実装に渡され、スコアを取得します。
次にそのメッセージは、コンテナから最も高いスコアを持つ IScorable に渡されて処理されますScorable の詳細については、こちらのサンプルを参照してください。
前の演習から得られたアプリを開きます。
または、exercise6-MoodDetection フォルダーにあるアプリを使用することもできます。
あらかじめ提供しているソリューションを使用する場合は、必ず以下の値を置き換えてください。
RootDialog.cs 内の LuisModel{LUISAppID}, {LUISKey} 属性のプレースホルダーを、自分が使用している LUIS アプリ ID とプログラマティック API キーに置き換えます
Web.config 内の TextAnalyticsApiKey を、自分が使用している Text Analytics キーに置き換えます 演習 6 で説明しています。
Web.config 内の AzureSearchAccount、AzureSearchIndex、および AzureSearchKey を、自分の Search アカウント、インデックス名、およびキーに置き換えます 演習 4 で説明しています。
プロジェクトに HandOff フォルダーを作成し、assets フォルダーの次のファイルを追加します。
通常ユーザーをエージェントに切り替え、エージェントを識別する、シンプルなロジックが含まれています。
これを使用して、いずれは、会話、ユーザー、およびエージェントを管理する独自のロジックを実装できます。
ヒューマン エージェントとの通信を待つユーザーを入れるキューを作成します。
このクラスでは、外部ストレージでキューを存続させません。
これは、会話のメタデータを格納する場所でもあります。
会話をデータ ストアに格納する場合は、カスタムの実装で Provider を更新するか、カスタムの実装を含む Provider を継承できます。
この Scorable はメッセージがエージェントからの場合にアクセスされ、agent help、connect、または resume メッセージを受信した場合に限り、その解決をトリガーします。
ユーザーのメッセージがこれらのメッセージと一致しない場合、ユーザーのメッセージはこの Scorable で処理されません。
次のコード例を使用して、RouterScorable.cs クラスを HandOff フォルダーに作成します。
ルーターには、各メッセージがエージェントまたはユーザーのどちらに送信される必要があるかを把握する役割があります。
PrepareRouteableAgentActivity は、メッセージが通常ユーザーと接続されているエージェントからのものであれば、Scorable をトリガーします。
PrepareRouteableUserActivity は、メッセージが、エージェントとの通信を待機している通常ユーザーかエージェントに接続されている通常ユーザーからのものであれば、Scorable をトリガーします。
PostAsync メソッドを RouterScorable.cs に追加します。
この Scorable がメッセージの解決に成功したら、ConversationReference はメッセージの宛先を受信します。
宛先が現在の会話と同じユーザーである場合、Scorable はそのユーザーにメッセージを送信して、キューの状態を通知します。
それ以外の場合、Scorable は受信メッセージを宛先にルーティングします。
ボットを更新して会話をハンドオフ
このタスクでは、ルーティングを行う Scorable に接続するようにボットを更新し、会話のハンドオフ フローを処理するために必要なダイアログを追加します。
LUIS ポータルを開き、次の発話を含む HandOffToHuman インテントを追加するようにアプリを編集します。
必要に応じて、こちらの LUIS モデルをインポートして使用できます。
アプリをトレーニングして再度発行します。
assets フォルダーにある AgentLoginScorable.cs を Dialogs フォルダーにコピーします。
このクラスは、通常ユーザーとヒューマン エージェント間の切り替えを管理します。
Global.asax.cs を開き、次の using ステートメントを追加します。
RootDialog.cs で、HandOffToHuman インテントを処理し、エージェントと通信するためのキューにユーザーを入れる HandOff メソッドを追加します。
さらに次の using ステートメントを使用します。
さらに次の using ステートメントを使用します。
エミュレーターからのボットのテスト
実行 ボタンをクリックしてアプリを実行し、エミュレーターの 2 つのインスタンスを開きます。
両方にボットの URL Local host  をいつもどおり入力します。
1 つのエミュレーターで、 I need to reset my password, this is urgent と入力して、新しいチケットを作成し、送信を確認します。
ボットからフィードバックを求められたら、 it was useless などの否定的なフレーズを入力します。
エージェントと話すかどうかを尋ねる、新しいプロンプトが表示されるはずです。
待機ユーザーのキューにユーザーを入れるためのプロンプトを確認します。
2 つ目のエミュレーターでは、 /agent login と入力して、エージェントの権限を制御します。
ボットから、1 人のユーザーが待機中であることが通知されるはずです。
 agent help と入力すると、エージェントの選択肢を含むメッセージが表示されます。
 connect と入力して、ユーザーとの会話を開始します。
1 番目のエミュレーターでは、ボットがこの接続をユーザーに通知します。
エージェントのメッセージ	ユーザーのメッセージ
エミュレーターを使用して、エージェントとユーザー間の通信を確認できるようになりました。
エージェントのメッセージ	ユーザーのメッセージ
対話を終了するには、2 番目のエミュレーター エージェント エミュレーター で resume と入力します。
ボットから両方の参加者に通信の終了が通知されます。
エージェントのメッセージ	ユーザーのメッセージ
もう 1 つの考えられるシナリオは 管理されたハンドオフ です。
このケースでは、ボットがユーザーの質問に応じてヒューマン エージェントと通信し、ボットが用意しているどの答えが正しいかを尋ねます。
自主的に学習を続ける場合は、次のタスクを利用できます。
Cosmos DB や SQL Server などの外部データ ストアに会話データを格納するカスタム プロバイダーを作成します。
AgentLoginScorable の認証を追加します。
ユーザーの認証プロセスを起動するには、Sign-inCard を追加する必要があります。
Provider.cs を変更して、会話データが持続されるようにします。
現状では、アクティブな会話はメモリ内に格納され、ボットの拡大/縮小は困難です。
ルーターに新しい状態を実装して、会話を監視できます。
この場合、ユーザーとボットのメッセージはヒューマン エージェントに送信され監視されます。
ボットは、人間の応答を待機中、既定の応答を使用して、すべての受信ユーザー メッセージに自動的に対応します。
never mind や cancel などの特定のメッセージをユーザーが送信した場合、ボットに 待機 状態から会話を削除させることができます。
ハンドオフの別の方法として、ヘルプ ダイアログに、会話を人間にハンドオフするボタンを追加します。
バックチャネルを通したイベントの送受信 C
バックチャネル メカニズムを使用すると、ユーザーからは見えない情報をクライアント アプリとボットがやり取りできます。
たとえば、クライアントのタイム ゾーンの要求や GPS の位置情報の読み取り、Web ページでのユーザーの操作内容などがあります。
ボットがユーザーをガイドして、Web フォームの一部に自動的に記入することなどもできます。
バックチャネルは、JavaScript クライアント アプリとボットの隔たりを埋める役割を果たします。
このメカニズムは、Direct Line API を使用して実装します。
この API を使用すると、クライアントとボットの間でアクティビティを送受信できます。
この演習では、アプリに Web ページを追加します。
ボットと Web ページはバックチャネル メカニズムを使用して通信を行います。
ボットはユーザーのチケットを Web ページに送信し、Web ページではそのチケットに関連するサポート技術情報の記事を表示します。
目標は、人間のスーパーバイザー エージェントが会話を監視し、Web ページを使用してユーザーに役立つ記事があるかどうかを判断し、チケットの作成を回避できるようにすることです。
ユーザーが記事を見つけたら、スーパーバイザー エージェントはその記事をクリックし、ユーザーとボットの会話で表示します。
ボットのバックチャネル パターンについては、こちらの記事で詳しく説明します。
こちらのフォルダー内には、この演習のステップの完了結果として得られるコードを含むソリューションが入っています。
このソリューションは、演習を進めるにあたってさらにヒントが必要な場合に、ガイダンスとして使用できます。
これを使用する前に、まず Web.config で LUIS モデルの値、および Azure Search インデックスの名前とキーを指定しておく必要があることを覚えておいてください。
この図は、この演習のコンポーネントを簡単に示しています。
この演習を完了するには、以下のソフトウェアが必要です。
Visual Studio 2017 Community 以上
Azure サブスクリプション
Bot Framework Emulator en-US ロケールで構成されていることを確認してください
ローカル開発用 ngrok
ボットの Web チャット チャネルへの新しいサイトの追加
Bot Framework ポータルにサインインします。
My bots ボタンをクリックし、編集するボットをクリックします。
この演習では、Bot Framework ポータルにボットが既に登録されていることを前提としています。
登録していない場合は、演習 5 の説明を参照してください。
Web チャット チャネルの 編集  リンクをクリックします。
開いたウィンドウで Add new site をクリックします。
サイト名  ヘルプ デスク チケット検索 を入力します。
完了 をクリックすると、次のページが表示されます。
秘密鍵が 2 つあることに注意してください。
後で使用できるように、いずれか 1 つを保存しておきます。
完了 をクリックします。
埋め込み済み Web チャットによる HTML ページの追加
このタスクでは、Web Chat コントロールと、ボットに event メッセージを送受信するコードが含まれるアプリに HTML ページを追加します。
次に、event アクティビティをボットから Web ページに送信する BackChannel 機能を追加します。
前の演習から得られたアプリを開きます。
または、exercise7-HandOffToHuman フォルダーにあるソリューションを使用することもできます。
あらかじめ提供しているソリューションを使用する場合は、必ず以下の値を置き換えてください。
    > - RootDialog.cs 内の LuisModel{LUISAppID}, {LUISKey} 属性のプレースホルダーを、自分が使用している LUIS アプリ ID とプログラマティック API キーに置き換えます
Web.config 内の TextAnalyticsApiKey を、自分が使用している Text Analytics キーに置き換えます 演習 6 で説明しています。
Web.config 内の AzureSearchAccount、AzureSearchIndex、および AzureSearchKey を、自分の Search アカウント、インデックス名、キーに置き換えます 演習 4 で説明しています。
default.htm を こちらのテンプレートに置き換えます。
botchat.js script elementの下に、Web Channel Secret で DirectLine オブジェクトを作成する以下のコードを含む、新しいスクリプト要素を追加します。
{DIRECTLINE_SECRET} プレースホルダーを、これまでに取得した秘密鍵で置き換え、{BOT_ID} プレースホルダーをボット処理 ID  help-desk-bot で置き換えます。
オープンソースの Web Chat コントロールは、Direct Line API を使用してボットと通信を行います。
Direct Line API を使用することで、activities をクライアントとボットの間で送受信できます。
最も一般的な型のアクティビティは message ですが、その他の型もあります。
たとえば、typing 型のアクティビティは、ユーザーが入力していること、またはボットが応答のコンパイル作業中であることを示します。
同じスクリプト要素で、event アクティビティを受信するためのボット アクティビティ リスナーを追加し、記事リストを表示します。
Web Chat コントロールは、type=event のアクティビティを自動的に無視します。
これにより、ページはボットと、ボットはページと直接通信を行うことができます。
わかりやすくするため、ユーザーとの会話を含む Web Chat コントロールと検索結果は同じページに表示します。
ただし、この 2 つはそれぞれ別々に扱うことが理想的です。
エージェントが監視と推奨記事の送信ができるように、スーパーバイザー Web サイトには進行中の会話のリストを表示する必要があります。
ボットを更新して event アクティビティを Web アプリに送信
このタスクではevent メッセージをボットと送受信する機能を追加します。
次の using ステートメントを追加します。
SubmitTicket メソッドを更新して、ボットはチケットの説明を受信すると新しい SendSearchToBackchannel メソッドを呼び出すようにします。
messageActivity パラメーターを導入する必要があります。
ボットから Web アプリへのバックチャネルのテスト
実行 ボタンをクリックしてアプリを実行します。
ngrok をダウンロードした新しいコンソール ウィンドウが開き、そのウィンドウで、ngrok http 3979 -host-header=localhost と入力します。
3979 は、ボットを実行しているポート番号であることに注意してください。
別のポート番号を使用している場合は、変更します。
次に、転送先の https URL も保存しておきます。
IIS Express ではどの開発サイトを表示するかを Host ヘッダーを使用して判別するため、-host-header 修飾子を使用する必要があります。
詳細については、こちらを参照してください。
Bot Framework ポータルにサインインします。
My bots ボタンをクリックし、次に、編集するボットをクリックします。
設定 タブをクリックして、メッセージのエンドポイント URL を ngrok から取得した転送先 https URL で更新します /api/messages を忘れずに保持してください。
変更の保存 ボタンをクリックします。
Web ブラウザでボットの URL に移動します いつもどおり Local host です。
Web Chat コントロールで、 I need to reset my password, this is urgent 急いでパスワードを変更する必要があります と入力します。
入力した説明に応じて、右側に記事リストが表示されるのがわかります。
Web ページを更新して event メッセージをボットに送信
default.htm ファイルを開きます。
ファイル冒頭の <style> セクションで、results h3 selector を次の CSS で置き換えます。
createSearchResult 関数を次のコードで更新します。
このコードは、ユーザーが記事のタイトルをクリックすると、event アクティビティをボットにポストします。
ボットを更新して event アクティビティを受信
Controllers\MessagesController.cs を開き、次の using ステートメントを追加します。
Post メソッドを以下のコードで更新して、ユーザーが記事のタイトルをクリックすると呼び出される event メッセージを処理します。
次のコードを追加して、showDetailsOf イベントを処理します。
このメソッドは、サポート技術情報で記事のタイトルを検索し、結果を Web Chat コントロールでユーザーに送信します。
アプリからボットへのバックチャネル メッセージのテスト
実行 ボタンをクリックしてアプリを実行します。
引き続き ngrok が実行中であることを確認します ngrok http 3979 -host-header=localhost。
Web ブラウザでボットの URL に移動します いつもどおり Local host Chat コントロールで、 My computer is not working コンピューターが動作していません と入力します。
いずれかの記事のタイトルをクリックすると、Web Chat コントロールに記事のコンテンツが表示されます。
